{% extends 'displayers.html' %}
{% block title %}<title>Quiz {{ quiz_id }}</title>{% endblock %}
{% block scripts %}
    {% load static %}
        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.2/dist/tf.min.js"></script>
        <script src="{% static 'js/predictors.js' %}"></script>
{% endblock %}
{% block css %}
    {% load static %}
        <link rel="stylesheet" type="text/css" href="{% static 'css/quiz.css' %}">
{% endblock %}
{% block body %}
    <script type="text/javascript">
        let idDict = {};
        let dataSet = {};
        let eventSet = {};
        let submissionSet = {};
        passableData = [];

        // TODO: Add warning when the button lock is true and the button is pressed
        let buttonLock = true;
        idDict.totalPageLeaveNo = setInterval(function() {
            randomChangeNumber(document.getElementById("total-page-leavers-no"));
        }, 50);
        idDict.totalUniquePageLeaversNo = setInterval(function() {
            randomChangeNumber(document.getElementById("total-page-leaves-no"));
        }, 50);
        idDict.std = setInterval(function () {
            randomChangeNumber(document.getElementById("std-no"), true);
        }, 50);
        idDict.stdAbove = setInterval(function () {
            randomChangeNumber(document.getElementById("std-above-no"));
        }, 50);


        $.ajax({
            "url": "{% url 'canvaswrapper:quiz-get-stats' %}",
            "method": "GET",
            "dataType": "json",
            "data": {"course_id": {{ course_id }}, "quiz_id": {{ quiz_id }}},
            success: function (results) {
                console.log(results);
                loadStats(results);
            },
            error: function(results) {
                // TODO: Fail Case
                console.log(results);
            }
        });


        function randomChangeNumber(element, percent=false) {
            if (percent) {
                element.innerText = Math.floor(Math.random() * Math.floor(100)) + "%";
            }
            else {
                element.innerText = Math.floor(Math.random() * Math.floor(100));
            }
        }


        function genericP(text, parent) {
            let newGenericP = document.createElement("p");
            newGenericP.className = "generic-p";
            newGenericP.innerText = text;
            newGenericP.style.opacity = "0";
            parent.appendChild(newGenericP);
            return newGenericP;
        }


        function loadStats(results) {
            results = JSON.parse(results["success"]["data"]);
            clearInterval(idDict.std);
            document.getElementById("std-no").innerText = Math.round(results["std"] * 100) + "%";

            clearInterval(idDict.stdAbove);
            document.getElementById("std-above-no").innerText = results["no_above_2_std"] === null ? 0 : results["no_above_2_std"];
            let twoAbove = document.createElement("b");
            twoAbove.innerText = "(" + Math.round(results["std"] * 200) + "%)";
            let stdAboveDesc = document.getElementById("std-above-desc");
            stdAboveDesc.appendChild(document.createElement("br"));
            document.getElementById("std-above-desc").appendChild(twoAbove);

        }


        $.ajax({
            url: "{% url 'canvaswrapper:quiz-get-submissions'%}",
            method: "GET",
            dataType: "json",
            data: {"course_id": {{ course_id }}, "quiz_id": {{ quiz_id }}},
            success: function(results) {
                console.log(results);
                loadMoreStatistics(results["success"]["data"]);
            },
            error: function(results) {
                // TODO: Fail Case
                console.log(results);
            }
        });



        function loadMoreStatistics(results) {
            // TODO: Assign globals here
            buttonLock = false;
            document.getElementById("start-button").style.opacity = "1";

            dataSet = results["user_to_page_leaves"];
            eventSet = results["user_to_events"];
            submissionSet = results["user_to_submissions"];
            clearInterval(idDict.totalPageLeaveNo);
            document.getElementById("total-page-leaves-no").innerText = results["page_leaves"];

            clearInterval(idDict.totalUniquePageLeaversNo);
            document.getElementById("total-page-leavers-no").innerText = results["unique_page_leavers"];
        }


        function testFunc() {
            if (buttonLock) {
                return;
            }
            else {
                parseData();
            }
        }


        function buildData(userData, eventData, buildRel=false) {
            // TODO: This function is a bit odd since it uses local variables but is being called with globals
            // so it's modifying globals in place, making the locals irrelevant
            let userIds = Object.keys(userData);
            let currentEvents = null;
            let currentId = null;
            let prevTime = null;
            let curTime = null;
            let localStart = null;
            let sum = 0;
            let denominator = 0;
            let overall_time_between_sum = 0;
            let overall_time_taken_sum = 0;
            let overall_page_leaves_sum = 0;
            let overall_denominator = 0;

            let time_taken_max = 0;
            let time_taken_min = null;

            let page_leaves_max = 0;
            let page_leaves_min = null;

            let time_between_max = 0;
            let time_between_min = null;

            for (let i =0; i<userIds.length; i++) {
                currentId = userIds[i];
                currentEvents = eventData[currentId]["quiz_submission_events"];
                prevTime = null; curTime = null; sum = 0; denominator = 0; localStart = null; // I'm not 100% how memory management works in js, but I felt it was better not to create a new variable every iteration

                for (let i = 0; i < currentEvents.length; i++) {
                    if (currentEvents[i]["event_type"] === "session_started") {
                        localStart = new Date(currentEvents[i]["created_at"]);
                    }

                    else if (currentEvents[i]["event_type"] !== "question_answered") {
                        continue;
                    }

                    else {
                        if (prevTime == null) {
                            prevTime = new Date(currentEvents[i]["created_at"]);
                        }
                        else {
                            curTime = new Date(currentEvents[i]["created_at"]);
                            let curCalc = Math.abs(curTime - prevTime);
                            sum += curCalc;
                            overall_time_between_sum += curCalc;
                            prevTime = curTime;
                            denominator += 1;
                            overall_denominator += 1;
                        }
                    }
                }

                if (denominator === 0 && prevTime !== null) {
                    // This is the case where there is only one question or the user only answered one
                    // So the time between questions is the time between submission and the first question answered.
                    let curCalc = Math.abs(prevTime - localStart);
                    userData[currentId]["average_time_between_questions"] = curCalc;
                    overall_time_between_sum += curCalc;
                    userData[currentId]["time_taken"] = submissionSet[currentId]["time_spent"];
                    overall_time_taken_sum += submissionSet[currentId]["time_spent"];
                    overall_page_leaves_sum += dataSet[currentId]["page_leaves"];
                    overall_denominator += 1;

                    if (userData[currentId]["average_time_between_questions"] > time_between_max) {
                        time_between_max = userData[currentId]["average_time_between_questions"];
                    }
                    if (userData[currentId]["time_taken"] > time_taken_max) {
                        time_taken_max = userData[currentId]["time_taken"];
                    }
                    if (userData[currentId]["page_leaves"] > page_leaves_max) {
                        page_leaves_max = userData[currentId]["page_leaves"];
                    }
                    if (userData[currentId]["average_time_between_questions"] < time_between_min || time_between_min == null) {
                        time_between_min = userData[currentId]["average_time_between_questions"];
                    }
                    if (userData[currentId]["time_taken"] < time_taken_min || time_taken_min == null) {
                        time_taken_min = userData[currentId]["time_taken"];
                    }
                    if (userData[currentId]["page_leaves"] < page_leaves_min || page_leaves_min == null) {
                        page_leaves_min = userData[currentId]["page_leaves"]
                    }
                }
                else if (denominator === 0) {
                    // This is the case where either there are no questions or the user did not answer any
                    // The user is deleted as the user cannot cheat if they didn't answer a question!
                    delete userData[currentId];
                }
                else {
                    userData[currentId]["average_time_between_questions"] = sum / denominator;
                    userData[currentId]["time_taken"] = submissionSet[currentId]["time_spent"];
                    overall_time_taken_sum += submissionSet[currentId]["time_spent"];
                    overall_page_leaves_sum += dataSet[currentId]["page_leaves"];
                    if (userData[currentId]["average_time_between_questions"] > time_between_max) {
                        time_between_max = userData[currentId]["average_time_between_questions"];
                    }
                    if (userData[currentId]["time_taken"] > time_taken_max) {
                        time_taken_max = userData[currentId]["time_taken"];
                    }
                    if (userData[currentId]["page_leaves"] > page_leaves_max) {
                        page_leaves_max = userData[currentId]["page_leaves"];
                    }
                    if (userData[currentId]["average_time_between_questions"] < time_between_min || time_between_min === null) {
                        time_between_min = userData[currentId]["average_time_between_questions"];
                    }
                    if (userData[currentId]["time_taken"] < time_taken_min || time_taken_min === null) {
                        time_taken_min = userData[currentId]["time_taken"];
                    }
                    if (userData[currentId]["page_leaves"] < page_leaves_min || page_leaves_min === null) {
                        page_leaves_min = userData[currentId]["page_leaves"]
                    }
                }
            }

            let rel_average_time_between = overall_time_between_sum / overall_denominator;
            let rel_time_taken = overall_time_taken_sum / overall_denominator;
            let rel_page_leaves = overall_page_leaves_sum / overall_denominator;
            if (buildRel) {
                for (let i = 0; i < userIds.length; i++) {
                    console.log(dataSet);
                    let currentUser = userData[userIds[i]];
                    // TODO: If you find a better way of scaling data column-wise in tensorflow, remake this
                    currentUser["average_time_between_questions"] = (currentUser["average_time_between_questions"] - time_between_min) / (time_between_max - time_between_min);
                    currentUser["time_taken"] = (currentUser["time_taken"] - time_taken_min) / (time_taken_max - time_taken_min);
                    currentUser["page_leaves"] = (currentUser["page_leaves"] - page_leaves_min) / (page_leaves_max - page_leaves_min);

                    // TODO: Rel is broken for now since I normlize the data
                    currentUser["rel_average_time_between_questions"] = currentUser["average_time_between_questions"] - rel_average_time_between;
                    currentUser["rel_time_taken"] = currentUser["time_taken"] - rel_time_taken;
                    currentUser["rel_page_leaves"] = currentUser["page_leaves"] - rel_page_leaves;
                    // TODO: Come back and make this not like this please. Build the list instead of building a temporary dictionary
                    passableData.push(
                        {
                            "id": currentId,
                            "page_leaves": currentUser["page_leaves"],
                            "average_time_between_questions": currentUser["average_time_between_questions"],
                            "time_taken": currentUser["time_taken"],
                            "rel_average_time_between_questions": currentUser["rel_average_time_between_questions"],
                            "rel_time_taken": currentUser["rel_time_taken"],
                            "rel_page_leaves": currentUser["rel_page_leaves"]
                        },
                    );
                }
            }
        }


        function parseData() {
            buildData(dataSet, eventSet, true);
            loadModel(passableData);
        }

    </script>

    <!-- TODO: Rename function  -->
    <button onclick="testFunc();" id="start-button">Check For Cheaters</button>
    <div id="title"></div>
    <div id="submissions"></div>
    <div id="statistics">
        <h1>Important Statistics</h1>
        <div id="std-div">
            <p class="number" id="std-no">0</p>
            <p class="text">Standard Deviation</p>
        </div>

        <div id="std-no-div">
            <p class="number" id="std-above-no">0</p>
            <p class="text" id="std-above-desc">Student(s) above or at 2 standard deviations</p>
        </div>

        <div id="total-page-leaves">
            <p class="number" id="total-page-leaves-no">0</p>
            <p class="text">Total Page Leave(s)</p>
        </div>

        <div id="total-page-leavers">
            <p class="number" id="total-page-leavers-no">0</p>
            <p class="text text-last">Student(s) left the page at least once during the test</p>
        </div>
    </div>

{% endblock %}